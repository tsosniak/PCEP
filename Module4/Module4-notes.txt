https://edube.org/learn/programming-essentials-in-python-part-1-v1-1/python-essentials-1-module-4-1

1. Why do we need functions?
- a particular piece of code is repeated many times in your program: programmer will have a lot of drudgery to find all the places that need corrections.
There's also a high risk of the corrections causing errors.

RULES:
1. if a particular fragment of the code begins to appear in more than one place, consider the possibility of isolating it in the form of a function invoked from the points where the original code was placed before
2. if a piece of code becomes so large that reading and understating it may cause a problem, consider dividing it into separate, smaller problems, and implement each of them in the form of a separate function.
A good and attentive developer divides the code (or more accurately: the problem) into well-isolated pieces, and encodes each of them in the form of a function.
This considerably simplifies the work of the program, because each piece of code can be encoded separately, and tested separately. The process described here is often called decomposition.
3.Decomposition
if you're going to divide the work among multiple programmers, decompose the problem to allow the product to be implemented as a set of separately written functions packed together in different modules.
This kind of decomposition has a different purpose to the one described previously - it's not only about sharing the work, but also about sharing the responsibility among many developers.
Each of them writes a clearly defined and described set of functions, which when combined into the module (we'll tell you about this a bit later) will give the final product.

2. Functions
def function_name():
    function_body

It always starts with the keyword def (for define)
next after def goes the name of the function (the rules for naming functions are exactly the same as for naming variables)
after the function name, there's a place for a pair of parentheses (they contain nothing here, but that will change soon)
the line has to be ended with a colon;
the line directly after def begins the function body - a couple (at least one) of necessarily nested instructions, which will be executed every time the function is invoked; note: the function ends where the nesting ends, so you have to be careful.

when you invoke a function, Python remembers the place where it happened and jumps into the invoked function;
the body of the function is then executed;
reaching the end of the function forces Python to return to the place directly after the point of invocation.

!!!You mustn't invoke a function which is not known at the moment of invocation!!!!
Remember - Python reads your code from top to bottom. It's not going to look ahead in order to find a function you forgot to put in the right place
You end up with NameError

!!!You mustn't have a function and a variable of the same name.!!!

3. Key takeaways

1. A function is a block of code that performs a specific task when the function is called (invoked). You can use functions to make your code reusable, better organized, and more readable. Functions can have parameters and return values.

2. There are at least four basic types of functions in Python:

built-in functions which are an integral part of Python (such as the print() function). You can see a complete list of Python built-in functions at https://docs.python.org/3/library/functions.html.
the ones that come from pre-installed modules (you'll learn about them in the Python Essentials 2 course)
user-defined functions which are written by users for users - you can write your own functions and use them freely in your code,
the lambda functions (you'll learn about them in the Python Essentials 2 course.)
3. You can define your own function using the def keyword and the following syntax:

def your_function(optional parameters):
    # the body of the function


You can define a function which doesn't take any arguments, e.g.:

def message():    # defining a function
    print("Hello")    # body of the function

message()    # calling the function


You can define a function which takes arguments, too, just like the one-parameter function below:

def hello(name):    # defining a function
    print("Hello,", name)    # body of the function


name = input("Enter your name: ")

hello(name)    # calling the function


We'll tell you more about parametrized functions in the next section. Don't worry.


4. Parameterized functions
The function's full power reveals itself when it can be equipped with an interface that is able to accept data provided by the invoker
parameters exist only inside functions in which they have been defined, and the only place where the parameter can be defined is a space between a pair of parentheses in the def statement;
assigning a value to the parameter is done at the time of the function's invocation, by specifying the corresponding argument.

Don't forget:
parameters live inside functions (this is their natural environment)
arguments exist outside functions, and are carriers of values passed to corresponding parameters.

def message(number):
    ###
The definition specifies that our function operates on just one parameter named number. You can use it as an ordinary variable, but only inside the function - it isn't visible anywhere else.

Remember: specifying one or more parameters in a function's definition is also a requirement, and you have to fulfil it during invocation. You must provide as many arguments as there are defined parameters.
Failure to do so will cause an error.

It's legal, and possible, to have a variable named the same as a function's parameter.
A situation like this activates a mechanism called shadowing:
parameter x shadows any variable of the same name, but...
... only inside the function defining the parameter.

A function can have as many parameters as you want, but the more parameters you have, the harder it is to memorize their roles and purposes.


5. Positional parameter passing vs. Keyword argument passing
The concept is clear - the values passed to the parameters are preceded by the target parameters' names, followed by the = sign.
you mustn't use a non-existent parameter name (TypeError)

6. Mixing positional and keyword arguments
!!!you have to put positional arguments before keyword arguments.!!!

Be careful, and beware of mistakes. If you try to pass more than one value to one argument, all you'll get is a runtime error.
Look at the invocation below - it seems that we've tried to set a twice:
adding(3, a = 1, b = 2)
Python's response:
TypeError:

7. default (predefined) values
def introduction(first_name, last_name="Smith"):
    print("Hello, my name is", first_name, last_name)

8. Key takeaways
1. You can pass information to functions by using parameters. Your functions can have as many parameters as you need.

An example of a one-parameter function:

def hi(name):
    print("Hi,", name)

hi("Greg")


An example of a two-parameter function:

def hi_all(name_1, name_2):
    print("Hi,", name_2)
    print("Hi,", name_1)

hi_all("Sebastian", "Konrad")


An example of a three-parameter function:

def address(street, city, postal_code):
    print("Your address is:", street, "St.,", city, postal_code)

s = input("Street: ")
p_c = input("Postal Code: ")
c = input("City: ")

address(s, c, p_c)


2. You can pass arguments to a function using the following techniques:

positional argument passing in which the order of arguments passed matters (Ex. 1),
keyword (named) argument passing in which the order of arguments passed doesn't matter (Ex. 2),
a mix of positional and keyword argument passing (Ex. 3).
Ex. 1
def subtra(a, b):
    print(a - b)

subtra(5, 2)    # outputs: 3
subtra(2, 5)    # outputs: -3


Ex. 2
def subtra(a, b):
    print(a - b)

subtra(a=5, b=2)    # outputs: 3
subtra(b=2, a=5)    # outputs: 3

Ex. 3
def subtra(a, b):
    print(a - b)

subtra(5, b=2)    # outputs: 3
subtra(5, 2)    # outputs: 3


It's important to remember that positional arguments mustn't follow keyword arguments. That's why if you try to run the following snippet:

def subtra(a, b):
    print(a - b)

subtra(5, b=2)    # outputs: 3
subtra(a=5, 2)    # Syntax Error

Python will not let you do it by signalling a SyntaxError.




3. You can use the keyword argument passing technique to pre-define a value for a given argument:

def name(first_name, last_name="Smith"):
    print(first_name, last_name)

name("Andy")    # outputs: Andy Smith
name("Betty", "Johnson")    # outputs: Betty Johnson (the keyword argument replaced by "Johnson")

subtra(a=5, 2)
SyntaxError: positional argument follows keyword argument


9. Effects and results: the return instruction
immediate termination of the function's execution, and an instant return (hence the name) to the point of invocation.
using the return instruction is not obligatory
you can use it to terminate a function's activities on demand, before the control reaches the function's last line.

10. A few words about None
Its data doesn't represent any reasonable value - actually, it's not a value at all; hence, it mustn't take part in any expressions.
print(None + 2) --> ends with TypeError

None is a keyword.!!!
There are only two kinds of circumstances when None can be safely used:
when you assign it to a variable (or return it as a function's result)
when you compare it with a variable to diagnose its internal state.

11. Key takeaways

1. You can use the return keyword to tell a function to return some value. The return statement exits the function, e.g.:

def multiply(a, b):
    return a * b

print(multiply(3, 4))    # outputs: 12


def multiply(a, b):
    return

print(multiply(3, 4))    # outputs: None


2. The result of a function can be easily assigned to a variable, e.g.:

def wishes():
    return "Happy Birthday!"

w = wishes()

print(w)    # outputs: Happy Birthday!

Look at the difference in output in the following two examples:

# Example 1
def wishes():
    print("My Wishes")
    return "Happy Birthday"

wishes()    # outputs: My Wishes


# Example 2
def wishes():
    print("My Wishes")
    return "Happy Birthday"

print(wishes())

# outputs: My Wishes
#          Happy Birthday


3. You can use a list as a function's argument, e.g.:

def hi_everybody(my_list):
    for name in my_list:
        print("Hi,", name)

hi_everybody(["Adam", "John", "Lucy"])


4. A list can be a function result, too, e.g.:

def create_list(n):
    my_list = []
    for i in range(n):
        my_list.append(i)
    return my_list

print(create_list(5))


12. Functions and scopes
The scope of a name (e.g., a variable name) is the part of a code where the name is properly recognizable.
For example, the scope of a function's parameter is the function itself. The parameter is inaccessible outside the function.

A variable existing outside a function has a scope inside the functions' bodies, excluding those of them which define a variable of the same name.
scope of a variable existing outside a function is supported only when getting its value (reading).
!!!Assigning a value forces the creation of the function's own variable.!!!

the global keyword
There's a special Python method which can extend a variable's scope in a way which includes the functions' bodies (even if you want not only to read the values, but also to modify them)

changing the parameter's value doesn't propagate outside the function (in any case, not when the variable is a scalar, like in the example).
This also means that a function receives the argument's value, not the argument itself

if the argument is a list, then changing the value of the corresponding parameter doesn't affect the list (remember: variables containing lists are stored in a different way than scalars),
but if you change a list identified by the parameter (note: the list, not the parameter!), the list will reflect the change.


13. Key takeaways

1. A variable that exists outside a function has a scope inside the function body (Example 1) unless the function defines a variable of the same name (Example 2, and Example 3), e.g.:

Example 1:

var = 2


def mult_by_var(x):
    return x * var


print(mult_by_var(7))    # outputs: 14


Example 2:

def mult(x):
    var = 5
    return x * var


print(mult(7))    # outputs: 35


Example 3:

def mult(x):
    var = 7
    return x * var


var = 3
print(mult(7))    # outputs: 49


2. A variable that exists inside a function has a scope inside the function body (Example 4), e.g.:

Example 4:

def adding(x):
    var = 7
    return x + var


print(adding(4))    # outputs: 11
print(var)    # NameError


3. You can use the global keyword followed by a variable name to make the variable's scope global, e.g.:

var = 2
print(var)    # outputs: 2


def return_var():
    global var
    var = 5
    return var


print(return_var())    # outputs: 5
print(var)    # outputs: 5


14. Recursion - technique where a function invokes itself.
If you forget to consider the conditions which can stop the chain of recursive invocations, the program may enter an infinite loop
-RecursionError: maximum recursion depth exceeded

15. Key takeaways
1. A function can call other functions or even itself. When a function calls itself, this situation is known as recursion, and the function which calls itself and contains a specified termination condition (i.e., the base case - a condition which doesn't tell the function to make any further calls to that function) is called a recursive function.

2. You can use recursive functions in Python to write clean, elegant code, and divide it into smaller, organized chunks. On the other hand, you need to be very careful as it might be easy to make a mistake and create a function which never terminates. You also need to remember that recursive calls consume a lot of memory, and therefore may sometimes be inefficient.

When using recursion, you need to take all its advantages and disadvantages into consideration.

The factorial function is a classic example of how the concept of recursion can be put in practice:

# Recursive implementation of the factorial function.

def factorial(n):
    if n == 1:    # The base case (termination condition.)
        return 1
    else:
        return n * factorial(n - 1)


print(factorial(4)) # 4 * 3 * 2 * 1 = 24

https://edube.org/learn/programming-essentials-in-python-part-1-v1-1/tuples-and-dictionaries-14

16. Sequence types and mutability
A sequence type is a type of data in Python which is able to store more than one value (or less than one, as a sequence may be empty), and these values can be sequentially (hence the name) browsed, element by element.

mutability - is a property of any of Python's data that describes its readiness to be freely changed during program execution. There are two kinds of Python data: mutable and immutable.
Mutable data can be freely updated at any time
Immutable data cannot be modified in this way.

 A tuple is an immutable sequence type
tuple_1 = (1, 2, 4, 8)
tuple_2 = 1., .5, .25, .125

each tuple element may be of a different type

empty_tuple = () --> empty tuple
one-element tuple
one_element_tuple_1 = (1, )
one_element_tuple_2 = 1.,

If you want to get the elements of a tuple in order to read them over, you can use the same conventions to which you're accustomed while using lists.

don't try to modify a tuple's contents! - will cause a runtime error:
like: AttributeError: 'tuple' object has no attribute 'append'
    my_tuple.append(10000)
    del my_tuple[0]
    my_tuple[1] = -10

One of the most useful tuple properties is their ability to appear on the left side of the assignment operator
like swapping: t1, t2, t3 = t2, t3, t1

 tuple's elements can be variables


17. What is a dictionary?
The dictionary is another Python data structure. It's not a sequence type (but can be easily adapted to sequence processing) and it is mutable.
This means that a dictionary is a set of key-value pairs.

each key must be unique - it's not possible to have more than one key of the same value;
a key may be any immutable type of object: it can be a number (integer or float), or even a string, but not a list;
a dictionary is not a list - a list contains a set of numbered values, while a dictionary holds pairs of values;
the len() function works for dictionaries, too - it returns the numbers of key-value elements in the dictionary;
a dictionary is a one-way tool - if you have an English-French dictionary, you can look for French equivalents of English terms, but not vice versa.

The list of pairs is surrounded by curly braces, while the pairs themselves are separated by commas, and the keys and values by colons.
dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
phone_numbers = {'boss': 5551234567, 'Suzy': 22657854310}
empty_dictionary = {}

the dictionary as a whole can be printed with a single print() invocation.

!!! (*) In Python 3.6x dictionaries have become ordered collections by default. !!!

keys are case-sensitive: 'Suzy' is something different from 'suzy'.

you mustn't use a non-existent key.
The in operator, together with its companion, not in, can salvage this situation.

When you write a big or lengthy expression, it may be a good idea to keep it vertically aligned. T
# Example 1:
dictionary = {
              "cat": "chat",
              "dog": "chien",
              "horse": "cheval"
              }

Such ways of formatting code are called hanging indents.

https://edube.org/learn/programming-essentials-in-python-part-1-v1-1/tuples-and-dictionaries-methods-4
































