https://edube.org/learn/programming-essentials-in-python-part-1-v1-1/python-essentials-1-module-3-1

1. If

This conditional statement consists of the following, strictly necessary, elements in this and this order only:

the if keyword;
one or more white spaces;
an expression (a question or an answer) whose value will be interpreted solely in terms of True (when its value is non-zero) and False (when it is equal to zero);
a colon followed by a newline;
an indented instruction or set of instructions (at least one instruction is absolutely required); the indentation may be achieved in two ways - by inserting a particular number of spaces (the recommendation is to use four spaces of indentation), or by using the tab character; note: if there is more than one instruction in the indented part, the indentation should be the same in all lines; even though it may look the same if you use tabs mixed with spaces, it's important to make all indentations exactly the same - Python 3 does not allow mixing spaces and tabs for indentation

Some additional attention has to be paid in this case:

you mustn't use else without a preceding if;
else is always the last branch of the cascade, regardless of whether you've used elif or not;
else is an optional part of the cascade, and may be omitted;
if there is an else branch in the cascade, only one of all the branches is executed;
if there is no else branch, it's possible that none of the available branches is executed.

# Choose the larger number
if number1 > number2: larger_number = number1
else: larger_number = number2

Note: if any of the if-elif-else branches contains just one instruction, you may code it in a more comprehensive form (you don't need to make an indented line after the keyword, but just continue the line after the colon).

Pseudocode and introduction to loops
We'll ignore the requirements of Python syntax for now, and try to analyze the problem without thinking about the real programming. In other words, we'll try to write the algorithm, and when we're happy with it, we'll implement it.

2. Key takeaways

1. The comparison (or the so-called relational) operators are used to compare values. The table below illustrates how the comparison operators work, assuming that x = 0, y = 1, and z = 0:

Operator	Description	Example
==	returns if operands' values are equal, and False otherwise
x == y  # False
x == z  # True

!=	returns True if operands' values are not equal, and False otherwise
x != y  # True
x != z  # False

>	True if the left operand's value is greater than the right operand's value, and False otherwise
x > y  # False
y > z  # True

<	True if the left operand's value is less than the right operand's value, and False otherwise
x < y  # True
y < z  # False

≥	True if the left operand's value is greater than or equal to the right operand's value, and False otherwise
x >= y  # False
x >= z  # True
y >= z  # True

≤	True if the left operand's value is less than or equal to the right operand's value, and False otherwise
x <= y  # True
x <= z  # True
y <= z  # False

2. When you want to execute some code only if a certain condition is met, you can use a conditional statement:

a single if statement, e.g.:

x = 10

if x == 10: # condition
    print("x is equal to 10")  # Executed if the condition is True.


a series of if statements, e.g.:

x = 10

if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.

if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.

if x == 10: # condition three
    print("x is equal to 10")  # Executed if condition three is True.


Each if statement is tested separately.




an if-else statement, e.g.:

x = 10

if x < 10:  # Condition
    print("x is less than 10")  # Executed if the condition is True.

else:
    print("x is greater than or equal to 10")  # Executed if the condition is False.


a series of if statements followed by an else, e.g.:

x = 10

if x > 5:  # True
    print("x > 5")

if x > 8:  # True
    print("x > 8")

if x > 10:  # False
    print("x > 10")

else:
    print("else will be executed")


Each if is tested separately. The body of else is executed if the last if is False.

The if-elif-else statement, e.g.:

x = 10

if x == 10:  # True
    print("x == 10")

if x > 15:  # False
    print("x > 15")

elif x > 10:  # False
    print("x > 10")

elif x > 5:  # True
    print("x > 5")

else:
    print("else will not be executed")


If the condition for if is False, the program checks the conditions of the subsequent elif blocks - the first elif block that is True is executed. If all the conditions are False, the else block will be executed.

Nested conditional statements, e.g.:

x = 10

if x > 5:  # True
    if x == 6:  # False
        print("nested: x == 6")
    elif x == 10:  # True
        print("nested: x == 10")
    else:
        print("nested: else")
else:
    print("else")


3. range() function
Note: the range() function accepts only integers as its arguments, and generates sequences of integers.
the range()'s second argument must be greater than the first.

4. loop
The loop's else branch is always executed once, regardless of whether the loop has entered its body or not.

i = 111
for i in range(2, 1):
    print(i)
else:
    print("else:", i)
ANSWER: else: 111

When the loop's body isn't executed, the control variable retains the value it had before the loop.

Note: if the control variable doesn't exist before the loop starts, it won't exist when the execution reaches the else branch.

5. Key takeaways

1. There are two types of loops in Python: while and for:

the while loop executes a statement or a set of statements as long as a specified boolean condition is true, e.g.:

# Example 1
while True:
    print("Stuck in an infinite loop.")

# Example 2
counter = 5
while counter > 2:
    print(counter)
    counter -= 1


the for loop executes a set of statements many times; it's used to iterate over a sequence (e.g., a list, a dictionary, a tuple, or a set - you will learn about them soon) or other objects that are iterable (e.g., strings). You can use the for loop to iterate over a sequence of numbers using the built-in range function. Look at the examples below:

# Example 1
word = "Python"
for letter in word:
    print(letter, end="*")

# Example 2
for i in range(1, 10):
    if i % 2 == 0:
        print(i)


2. You can use the break and continue statements to change the flow of a loop:

You use break to exit a loop, e.g.:

text = "OpenEDG Python Institute"
for letter in text:
    if letter == "P":
        break
    print(letter, end="")


You use continue to skip the current iteration, and continue with the next iteration, e.g.:

text = "pyxpyxpyx"
for letter in text:
    if letter == "x":
        continue
    print(letter, end="")





3. The while and for loops can also have an else clause in Python. The else clause executes after the loop finishes its execution as long as it has not been terminated by break, e.g.:

n = 0

while n != 3:
    print(n)
    n += 1
else:
    print(n, "else")

print()

for i in range(0, 3):
    print(i)
else:
    print(i, "else")


4. The range() function generates a sequence of numbers. It accepts integers and returns range objects. The syntax of range() looks as follows: range(start, stop, step), where:

start is an optional parameter specifying the starting number of the sequence (0 by default)
stop is an optional parameter specifying the end of the sequence generated (it is not included),
and step is an optional parameter specifying the difference between the numbers in the sequence (1 by default.)
Example code:

for i in range(3):
    print(i, end=" ")  # Outputs: 0 1 2

for i in range(6, 1, -2):
    print(i, end=" ")  # Outputs: 6, 4, 2

5. De Morgan's laws. They say that:
The negation of a conjunction is the disjunction of the negations.
The negation of a disjunction is the conjunction of the negations.
not (p and q) == (not p) or (not q)
not (p or q) == (not p) and (not q)

6. Bitwise operators - to manipulate single bits of data
xor (as in exclusive or) operator, and is denoted as ^ (caret).
Here are all of them:

& (ampersand) - bitwise conjunction;
| (bar) - bitwise disjunction;
~ (tilde) - bitwise negation;
^ (caret) - bitwise exclusive or (xor).

the arguments of these operators must be integers; we must not use floats here.

Note:

17 >> 1 → 17 // 2 (17 floor-divided by 2 to the power of 1) → 8 (shifting to the right by one bit is the same as integer division by two)
17 << 2 → 17 * 4 (17 multiplied by 2 to the power of 2) → 68 (shifting to the left by two bits is the same as integer multiplication by four)

7. Key takeaways

1. Python supports the following logical operators:

and → if both operands are true, the condition is true, e.g., (True and True) is True,
or → if any of the operands are true, the condition is true, e.g., (True or False) is True,
not → returns false if the result is true, and returns true if the result is false, e.g., not True is False.
2. You can use bitwise operators to manipulate single bits of data. The following sample data:

x = 15, which is 0000 1111 in binary,
y = 16, which is 0001 0000 in binary.
will be used to illustrate the meaning of bitwise operators in Python. Analyze the examples below:

& does a bitwise and, e.g., x & y = 0, which is 0000 0000 in binary,
| does a bitwise or, e.g., x | y = 31, which is 0001 1111 in binary,
˜  does a bitwise not, e.g., ˜ x = 240*, which is 1111 0000 in binary,
^ does a bitwise xor, e.g., x ^ y = 31, which is 0001 1111 in binary,
>> does a bitwise right shift, e.g., y >> 1 = 8, which is 0000 1000 in binary,
<< does a bitwise left shift, e.g., y << 3 = , which is 1000 0000 in binary,

* -16 (decimal from signed 2's complement) -- read more about the Two's complement operation.


https://edube.org/learn/programming-essentials-in-python-part-1-v1-1/lists-collections-of-data-2

